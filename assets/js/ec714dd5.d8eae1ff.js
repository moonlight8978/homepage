(self.webpackChunkmoonlight_8978_github_io=self.webpackChunkmoonlight_8978_github_io||[]).push([[7778],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return p},kt:function(){return m}});var a=t(7294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,s=function(e,n){if(null==e)return{};var t,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var i=a.createContext({}),u=function(e){var n=a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=u(e.components);return a.createElement(i.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,s=e.mdxType,r=e.originalType,i=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=u(t),m=s,_=c["".concat(i,".").concat(m)]||c[m]||d[m]||r;return t?a.createElement(_,o(o({ref:n},p),{},{components:t})):a.createElement(_,o({ref:n},p))}));function m(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var r=t.length,o=new Array(r);o[0]=c;var l={};for(var i in n)hasOwnProperty.call(n,i)&&(l[i]=n[i]);l.originalType=e,l.mdxType="string"==typeof e?e:s,o[1]=l;for(var u=2;u<r;u++)o[u]=t[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},8192:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return l},metadata:function(){return i},toc:function(){return u},default:function(){return d}});var a=t(2122),s=t(9756),r=(t(7294),t(3905)),o=["components"],l={},i={unversionedId:"ruby/arel",id:"ruby/arel",isDocsHomePage:!1,title:"Arel",description:"Last updated: 2020-12-16",source:"@site/docs/ruby/arel.md",sourceDirName:"ruby",slug:"/ruby/arel",permalink:"/docs/ruby/arel",editUrl:"https://github.com/moonlight8978/moonlight8978.github.io/edit/v2/docs/docs/ruby/arel.md",version:"current",lastUpdatedAt:1623035465,formattedLastUpdatedAt:"6/7/2021",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"ActiveStorage",permalink:"/docs/ruby/active-storage"},next:{title:"Enumerator and Large Response Streaming",permalink:"/docs/ruby/enumerator-and-large-response-streaming"}},u=[{value:"SQL",id:"sql",children:[{value:"Multiple counting metadata",id:"multiple-counting-metadata",children:[]},{value:"Sort by different column based on other column&#39;s value",id:"sort-by-different-column-based-on-other-columns-value",children:[]},{value:"Sort by enum column",id:"sort-by-enum-column",children:[]}]},{value:"Some notes on Arel",id:"some-notes-on-arel",children:[]}],p={toc:u};function d(e){var n=e.components,t=(0,s.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Last updated: 2020-12-16")),(0,r.kt)("h2",{id:"sql"},"SQL"),(0,r.kt)("h3",{id:"multiple-counting-metadata"},"Multiple counting metadata"),(0,r.kt)("p",null,"Scenario"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby",metastring:"title=app/models/company.rb",title:"app/models/company.rb"},"class Company < ApplicationRecord\n  has_many :users\nend\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby",metastring:"title=app/models/user.rb",title:"app/models/user.rb"},"class User < ApplicationRecord\n  extend Enumerize\n\n  belongs_to :company\n\n  has_many :medicals\n\n  enumerize :gender, in: [:male, :female]\n  enumerize :role, in: [:employee, :leader, :manager, :admin], default: :employee\nend\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby",metastring:"title=app/models/medical.rb",title:"app/models/medical.rb"},"class Medical < ApplicationRecord\n  extend Enumerize\n\n  belongs_to :user\n\n  enumerize :hospitalization, in: [:hospitalized, :treating_at_home]\nend\n")),(0,r.kt)("p",null,"\u2192\x10 Customer want to show following information of each company in company list page:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Total of male users, female users"),(0,r.kt)("li",{parentName:"ul"},"Average of all users' blood pressure, and total of hospitalized users (based on their last medical record)")),(0,r.kt)("p",null,"PostgreSQL:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DISTINCT ON")," makes life much easier")),(0,r.kt)("p",null,"MySQL: Use joins to eagerload ",(0,r.kt)("inlineCode",{parentName:"p"},"has_one")," association with scope"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ON")," operator determine which row of ",(0,r.kt)("inlineCode",{parentName:"li"},"medical")," will be joined with ",(0,r.kt)("inlineCode",{parentName:"li"},"user"),". Use conditional query here to get right record of ",(0,r.kt)("inlineCode",{parentName:"li"},"has_one")," association")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT\n  companies.*,\n  company_male_users_counts.male_users_count AS male_users_count,\n  company_female_users_counts.female_users_count AS female_users_count,\n  company_avg_blood_pressures.avg_blood_pressure AS avg_blood_pressure,\n  company_hospitalized_users_counts.hospitalized_users_count AS hospitalized_users_count\nFROM companies\n  INNER JOIN (\n    SELECT users.company_id, COUNT(users.id) AS male_users_count\n    FROM users\n    WHERE users.gender = 'male'\n    GROUP BY users.company_id\n  ) company_male_users_counts ON companies.id = company_male_users_counts.company_id\n  INNER JOIN (\n    SELECT users.company_id, COUNT(users.id) AS female_users_count\n    FROM users\n    WHERE users.gender = 'female'\n    GROUP BY users.company_id\n  ) company_female_users_counts ON companies.id = company_female_users_counts.company_id\n  INNER JOIN (\n    SELECT users.company_id, AVG(medicals.blood_pressure) AS avg_blood_pressure\n    FROM users\n      INNER JOIN medicals ON medicals.id = (\n        SELECT id FROM medicals\n        WHERE medicals.user_id = users.id\n        ORDER BY medicals.created_at DESC, medicals.id DESC\n        LIMIT 1\n      )\n    GROUP BY users.company_id\n  ) company_avg_blood_pressures ON companies.id = company_avg_blood_pressures.company_id\n  INNER JOIN (\n    SELECT users.company_id, COUNT(users.id) AS hospitalized_users_count\n    FROM users\n      INNER JOIN medicals ON medicals.id = (\n        SELECT id\n        FROM medicals\n        WHERE medicals.user_id = users.id\n        ORDER BY medicals.created_at DESC, medicals.id DESC\n        LIMIT 1\n      )\n    WHERE medicals.hospitalization = 'hospitalized'\n    GROUP BY users.company_id\n  ) company_hospitalized_users_counts ON companies.id = company_hospitalized_users_counts.company_id;\n")),(0,r.kt)("p",null,"Using Arel"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby",metastring:"title=app/models/company.rb",title:"app/models/company.rb"},"scope :with_counts, -> do\n  users = User.arel_table\n  medicals = Medical.arel_table\n\n  company_male_users_counts = users\n    .project(users[:company_id], users[:id].count.as('male_users_count'))\n    .where(users[:gender].eq(User.gender.male))\n    .group(users[:company_id])\n    .as('company_male_users_counts')\n\n  company_female_users_counts = users\n    .project(users[:company_id], users[:id].count.as('female_users_count'))\n    .where(users[:gender].eq(User.gender.female))\n    .group(users[:company_id])\n    .as('company_female_users_counts')\n\n  users_with_latest_medical = -> do\n    users\n      .join(medicals)\n      .on(\n        medicals[:id].eq(\n          medicals\n            .project(:id)\n            .where(medicals[:user_id].eq(users[:id]))\n            .order(medicals[:created_at].desc, medicals[:id].desc)\n            .take(1)\n        )\n      )\n  end\n\n  company_avg_blood_pressures = users_with_latest_medical.call\n    .project(users[:company_id], medicals[:blood_pressure].average.as('avg_blood_pressure'))\n    .group(users[:company_id])\n    .as('company_avg_blood_pressures')\n\n  company_hospitalized_users_counts = users_with_latest_medical.call\n    .project(users[:company_id], users[:id].count.as('hospitalized_users_count'))\n    .where(medicals[:hospitalization].eq(Medical.hospitalization.hospitalized))\n    .group(users[:company_id])\n    .as('company_hospitalized_users_counts')\n\n  companies = arel_table\n  joining = companies\n    .join(company_male_users_counts)\n      .on(companies[:id].eq(company_male_users_counts[:company_id]))\n    .join(company_female_users_counts)\n      .on(companies[:id].eq(company_female_users_counts[:company_id]))\n    .join(company_avg_blood_pressures)\n      .on(companies[:id].eq(company_avg_blood_pressures[:company_id]))\n    .join(company_hospitalized_users_counts)\n      .on(companies[:id].eq(company_hospitalized_users_counts[:company_id]))\n\n  self\n    .select(\n      companies[Arel.star],\n      company_male_users_counts[:male_users_count].as('male_users_count'),\n      company_female_users_counts[:female_users_count].as('female_users_count'),\n      company_avg_blood_pressures[:avg_blood_pressure].as('avg_blood_pressure'),\n      company_hospitalized_users_counts[:hospitalized_users_count].as('hospitalized_users_count'),\n    )\n    .joins(joining.join_sources)\nend\n")),(0,r.kt)("h3",{id:"sort-by-different-column-based-on-other-columns-value"},"Sort by different column based on other column's value"),(0,r.kt)("p",null,"Scenario:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby",metastring:"title=app/models/task.rb",title:"app/models/task.rb"},"class Task < ApplicationRecord\n  enumerize :status, in: [:todo, :in_progress, :done], default: :todo\nend\n\n")),(0,r.kt)("p",null,"\u2192 Customer want to see all tasks with sorted status by the following order: ",(0,r.kt)("inlineCode",{parentName:"p"},"todo")," < ",(0,r.kt)("inlineCode",{parentName:"p"},"in_progress")," < ",(0,r.kt)("inlineCode",{parentName:"p"},"done")),(0,r.kt)("p",null,"The key is using ",(0,r.kt)("inlineCode",{parentName:"p"},"CASE"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"WHEN"),". If different sort direction required, multiple CASE/WHEN statements are needed"),(0,r.kt)("p",null,"MySQL:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT\n  tasks.*,\n  CASE tasks.status\n  WHEN 'todo' THEN -1\n  WHEN 'in_progress' THEN 0\n  WHEN 'done' THEN 1 END AS status_int\nFROM tasks\nWHERE tasks.assignee_id = 1\nORDER BY\n  status_int ASC,\n  CASE tasks.status\n  WHEN 'todo' THEN tasks.created_at\n  WHEN 'in_progress' THEN tasks.started_at\n  WHEN 'done' THEN tasks.finished_at\n  END ASC,\n  tasks.id ASC;\n")),(0,r.kt)("p",null,"Using Arel"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby",metastring:"title=app/model/task.rb",title:"app/model/task.rb"},'scope :sort_view, -> do\n  tasks = arel_table\n\n  status_ordering_attr = "status_int"\n  status_mapping = Arel::Nodes::Case.new(tasks[:status])\n    .when(status.todo).then(-1)\n    .when(status.in_progress).then(0)\n    .when(status.done).then(1)\n    .as(status_ordering_attr)\n\n  time_ordering = Arel::Nodes::Case.new(tasks[:status])\n    .when(status.todo).then(tasks[:created_at])\n    .when(status.in_progress).then(tasks[:started_at])\n    .when(status.done).then(tasks[:finished_at])\n\n  self\n    .select(tasks[Arel.star], status_mapping.to_sql)\n    .order("#{status_ordering_attr} ASC", time_ordering.asc, tasks[:id].asc)\nend\n')),(0,r.kt)("h3",{id:"sort-by-enum-column"},"Sort by enum column"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sqls/sort_users.sql")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"app/models/user.rb")),(0,r.kt)("li",{parentName:"ul"},"Use temporary mapping table to map enum to right ordered-value"),(0,r.kt)("li",{parentName:"ul"},"Default Arel table is ",(0,r.kt)("inlineCode",{parentName:"li"},"DUAL"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"DUAL")," is a dummy table\n",(0,r.kt)("a",{parentName:"li",href:"https://www.w3resource.com/sql/sql-dual-table.php#:~:text=but%20DUAL%20can%20be%20accessed,but%20you%20could%20create%20one"},"https://www.w3resource.com/sql/sql-dual-table.php#:~:text=but%20DUAL%20can%20be%20accessed,but%20you%20could%20create%20one"),"."),(0,r.kt)("li",{parentName:"ul"},"Use ",(0,r.kt)("inlineCode",{parentName:"li"},"Arel::Nodes::TableAlias")," when using anonymous join tables")),(0,r.kt)("p",null,"MySQL"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT users.*\nFROM users\n  INNER JOIN (\n    (SELECT 'employee' AS role, 1 AS role_int FROM DUAL)\n    UNION ALL\n    (SELECT 'leader' AS role, 2 AS role_int FROM DUAL)\n    UNION ALL\n    (SELECT 'manager' AS role, 3 AS role_int FROM DUAL)\n    UNION ALL\n    (SELECT 'admin' AS role, 4 AS role_int FROM DUAL)\n  ) role_mappings ON users.role = role_mappings.role\nWHERE users.company_id = 1\nORDER BY role_mappings.role_int ASC;\n")),(0,r.kt)("p",null,"Arel"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby",metastring:"title=app/models/user.rb",title:"app/models/user.rb"},"scope :sort_view, -> do\n  user_roles = UserRole.instance.arel_table\n  users = arel_table\n\n  join_user_roles = users.join(user_roles).on(users[:role].eq(user_roles[:role]))\n  self.joins(join_user_roles.join_sources).order(user_roles[:role_int].asc)\nend\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby",metastring:"title=app/models/user_role.rb",title:"app/models/user_role.rb"},"class UserRole\n  include Singleton\n\n  def arel_table\n    return @arel_table if @arel_table\n\n    employee_row = Arel::SelectManager.new\n      .project(Arel::Nodes::Quoted.new(User.role.employee).as('role'))\n      .project(Arel::Nodes::SqlLiteral.new('1').as('role_int'))\n\n    leader_row = Arel::SelectManager.new\n      .project(Arel::Nodes::Quoted.new(User.role.leader).as('role'))\n      .project(Arel::Nodes::SqlLiteral.new('2').as('role_int'))\n\n    manager_row = Arel::SelectManager.new\n      .project(Arel::Nodes::Quoted.new(User.role.manager).as('role'))\n      .project(Arel::Nodes::SqlLiteral.new('3').as('role_int'))\n\n    admin_row = Arel::SelectManager.new\n      .project(Arel::Nodes::Quoted.new(User.role.admin).as('role'))\n      .project(Arel::Nodes::SqlLiteral.new('4').as('role_int'))\n\n    @arel_table = Arel::Nodes::TableAlias.new(\n      Arel::Nodes::UnionAll.new(\n        Arel::Nodes::UnionAll.new(\n          employee_row,\n          leader_row\n        ),\n        Arel::Nodes::UnionAll.new(\n          manager_row,\n          admin_row\n        )\n      ),\n      'role_mappings'\n    )\n  end\nend\n")),(0,r.kt)("h2",{id:"some-notes-on-arel"},"Some notes on Arel"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Arel build AST underhood")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Arel::SelectManager")," has methods to build AST tree, but ",(0,r.kt)("inlineCode",{parentName:"p"},"SelectManager")," can become an AST node itself")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Arel::Nodes::...")," is AST node")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Use ",(0,r.kt)("inlineCode",{parentName:"p"},"Arel::Nodes::TableAlias")," when using anonymous tables, it has ",(0,r.kt)("inlineCode",{parentName:"p"},"left")," node which can wrap relation (can be ",(0,r.kt)("inlineCode",{parentName:"p"},"Arel::SelectManager"),") and ",(0,r.kt)("inlineCode",{parentName:"p"},"#to_sql")," will be delegated to. It provides ",(0,r.kt)("inlineCode",{parentName:"p"},"#[]")," to access table attributes"))))}d.isMDXComponent=!0}}]);