<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="moonlight8978's Blog Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="moonlight8978's Blog Blog Atom Feed"><title data-react-helmet="true">Posts tagged &quot;introduction&quot; | moonlight8978&#x27;s Blog</title><meta data-react-helmet="true" property="og:title" content="Posts tagged &quot;introduction&quot; | moonlight8978&#x27;s Blog"><meta data-react-helmet="true" name="description" content="Blog | Tagged &quot;introduction&quot;"><meta data-react-helmet="true" property="og:description" content="Blog | Tagged &quot;introduction&quot;"><meta data-react-helmet="true" property="og:url" content="https://moonlight8978.github.io/blog/tags/introduction"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="blog_tags_posts"><link data-react-helmet="true" rel="shortcut icon" href="https://avatars.githubusercontent.com/u/26299310?v=4"><link data-react-helmet="true" rel="canonical" href="https://moonlight8978.github.io/blog/tags/introduction"><link data-react-helmet="true" rel="alternate" href="https://moonlight8978.github.io/blog/tags/introduction" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://moonlight8978.github.io/blog/tags/introduction" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.5f3c8191.css">
<link rel="preload" href="/assets/js/runtime~main.610c7904.js" as="script">
<link rel="preload" href="/assets/js/main.afbd8574.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="https://avatars.githubusercontent.com/u/26299310?v=4" alt="moonlight8978" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="https://avatars.githubusercontent.com/u/26299310?v=4" alt="moonlight8978" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">My Site</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/docs/intro">Programming notes</a><a class="navbar__item navbar__link" href="/books/intro">Book notes</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="https://avatars.githubusercontent.com/u/26299310?v=4" alt="moonlight8978" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="https://avatars.githubusercontent.com/u/26299310?v=4" alt="moonlight8978" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">My Site</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/blog">Blog</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/intro">Programming notes</a></li><li class="menu__list-item"><a class="menu__link" href="/books/intro">Book notes</a></li><li class="menu__list-item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper blog-wrapper blog-tags-post-page"><div class="container margin-vert--lg"><div class="row"><div class="col col--3"><div class="sidebar_2ahu thin-scrollbar"><h3 class="sidebarItemTitle_2hhb">All posts</h3><ul class="sidebarItemList_2xAf"><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/cung-tim-hieu-ve-puma-ruby-on-rails">Cùng tìm hiểu về Puma (Ruby on Rails)</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/cuoi-react-native-xem-appium-phan-1-cung-tim-hieu-cach-hoat-dong-cua-appium">Cưỡi React Native xem Appium (Phần 1 - Cùng tìm hiểu cách hoạt động của Appium)</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/gioi-thieu-ve-kubernetes">Giới thiệu về Kubernetes</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/toi-uu-menh-de-where-mysql">Tối ưu mệnh đề WHERE (MySQL)</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/cung-tim-hieu-ve-actiontext-trong-rails-6">Cùng tìm hiểu về ActionText trong Rails 6</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/cung-tim-hieu-ve-railway-oriented-programming">Cùng tìm hiểu về Railway Oriented Programming</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/mot-vai-mindset-khi-lam-viec-voi-react">Một vài mindset khi làm việc với React</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/cung-tim-hieu-ve-nguyen-tu-cua-the-gioi-front-end-phan-2-density-independent-pixel">Cùng tìm hiểu về nguyên tử của thế giới FrontEnd (Phần 2 - Density-independent Pixel)</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/cung-tim-hieu-ve-nguyen-tu-cua-the-gioi-front-end-phan-1-pixel">Cùng tìm hiểu về nguyên tử của thế giới FrontEnd (Phần 1 - Pixel)</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/tdd-bdd-noi-de-hon-lam">TDD/BDD - Nói dễ hơn làm</a></li></ul></div></div><main class="col col--7"><h1>One post tagged with &quot;introduction&quot;</h1><a href="/blog/tags">View All Tags</a><div class="margin-vert--xl"><article class="margin-bottom--xl"><header><h2 class="margin-bottom--sm blogPostTitle_GeHD"><a href="/blog/gioi-thieu-ve-kubernetes">Giới thiệu về Kubernetes</a></h2><div class="margin-vert--md"><time datetime="2019-11-21T00:00:00.000Z" class="blogPostDate_fNvV">November 21, 2019 · 11 min read</time></div><div class="avatar margin-vert--md"><a href="https://github.com/moonlight8978" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img src="https://avatars.githubusercontent.com/u/26299310?v=4" alt="Lê Sĩ Bích"></a><div class="avatar__intro"><h4 class="avatar__name"><a href="https://github.com/moonlight8978" target="_blank" rel="noopener noreferrer">Lê Sĩ Bích</a></h4><small class="avatar__subtitle">Ruby on Rails/React Developer</small></div></div></header><div class="markdown"><p>Ngày nay, container đã là 1 thứ gì đó quá phổ biến, những nền tảng cloud của Amazon, Google, hay Microsoft, v.v... đều đã hỗ trợ deploy container. Và ở local, hay những server test, mọi người cũng đang dần chuẩn sang container vì sự tiện lợi của chúng.</p><p>Tuy nhiên khi số lượng container lớn dần, chúng ngày càng trở nên rắc rối, việc control resource, network, volume của một số lượng lớn container ngày càng khó. Chính vì lý do đó, một số nền tảng quản lý container đã ra đời như Docker Swarm, Kubernetes, ...</p><p>Với một hệ thống nhỏ, ta có thể sử dụng Docker Swarm, sử dụng nó rất dễ và đơn giản. Kubernetes cho phép ta customize nhiều thứ trong hệ thống hơn, tuy nhiên cái giá của nó là khó sử dụng hơn nhiều Docker Swarm.</p><p>Note: Ta không bao giờ so sánh Kubernetes với Docker, vì k8s thứ là management tool, còn docker là container runtime.</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2-kiến-trúc-hạ-tầng-của-kubernetes"></a>2. Kiến trúc hạ tầng của Kubernetes<a class="hash-link" href="#2-kiến-trúc-hạ-tầng-của-kubernetes" title="Direct link to heading">#</a></h1><p><img src="https://images.viblo.asia/8fd57971-e1c9-41dd-b205-0ce88a356e50.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="21-master-components"></a>2.1 Master components<a class="hash-link" href="#21-master-components" title="Direct link to heading">#</a></h3><p>Những components trên master node sẽ đóng vai trò là control plane của cluster. VD như: scheduling các pod, ...</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="211-etcd"></a>2.1.1 etcd<a class="hash-link" href="#211-etcd" title="Direct link to heading">#</a></h5><p>Đây là database phân tán, sử dụng Raft làm cơ chế đồng thuận.</p><p>State của cluster (config, node info, IP addresses, ...) đều được lưu trữ tại đây.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="212-kube-scheduler"></a>2.1.2 kube-scheduler<a class="hash-link" href="#212-kube-scheduler" title="Direct link to heading">#</a></h5><p>Có nhiệm vụ schedule pod tới những node có đủ resource, và đảm bảo pod đạt được expected status.</p><p>Có thể hiểu đơn giản đây là một vòng lặp vô tận, đưa những pod mới được tạo vào 1 queue, từng item trong đó sẽ được schedule tới node thỏa mãn.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="213-kube-apiserver"></a>2.1.3 kube-apiserver<a class="hash-link" href="#213-kube-apiserver" title="Direct link to heading">#</a></h5><p>API Server đơn thuần là 1 REST API của Kubernetes cluster.</p><p>Khi muốn tạo, cập nhật, hay xóa những resource của hệ thống như pod, ingress, ... thì đều cần thông qua API Server, chứ không call thẳng tới kube-scheduler, etcd, ...</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="214-kube-controller-manager"></a>2.1.4 kube-controller-manager<a class="hash-link" href="#214-kube-controller-manager" title="Direct link to heading">#</a></h5><p>Chạy nhiều controller process. Mỗi controller có nhiệm vụ khác nhau như:</p><ul><li>Node Controller</li><li>Replication Controller</li><li>...</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="22-node-components"></a>2.2 Node components<a class="hash-link" href="#22-node-components" title="Direct link to heading">#</a></h3><p>Là những component được cài đặt trên tất cả các node, giúp quản lý container trên node, logging, quản lý network, ...</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="221-kubelet"></a>2.2.1 kubelet<a class="hash-link" href="#221-kubelet" title="Direct link to heading">#</a></h5><p>Có nhiệm vụ quản lý container, đảm bảo container chạy chính xác, kubelet chỉ quản lý container do k8s tạo.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="222-kube-proxy"></a>2.2.2 kube-proxy<a class="hash-link" href="#222-kube-proxy" title="Direct link to heading">#</a></h5><p>Là một network proxy, dùng để forward request tới hạ tầng của k8s.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="223-container-runtime"></a>2.2.3 Container runtime<a class="hash-link" href="#223-container-runtime" title="Direct link to heading">#</a></h5><p>Chắn chắn ta không thể thiếu runtime cho container, nó có thể là rkt, Docker, ... hay bất cứ thứ gì khác.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="23-hoạt-động"></a>2.3 Hoạt động<a class="hash-link" href="#23-hoạt-động" title="Direct link to heading">#</a></h3><p>Chúng ta sẽ cùng xem những component trên sẽ kết hợp với nhau hoạt động ra sao, thông qua việc tạo 1 Pod qua <code>kubectl</code> CLI.</p><p><strong>Pod</strong> ở đây có thể coi là 1 máy ảo, hay 1 container như Docker cho dễ hình dung.</p><p><img src="https://images.viblo.asia/f19795c9-fbc9-48e1-9391-53fc439c1391.jpg"></p><ul><li>Trước tiên ta sử dụng <code>kubectl</code> để yêu cầu tạo 1 Pod. Bản chất của command này là sẽ thực hiện 1 HTTP request tới <strong>apiserver</strong> của cluster.</li><li><strong>apiserver</strong> sẽ thực hiện ghi lại current state, và desired state của cluster lại vào <strong>etcd</strong> (asynchronous)</li><li><strong>etcd</strong> sẽ notify lại <strong>apiserver</strong> khi entry được tạo thành công</li><li>Tiếp theo <strong>kube-scheduler</strong> sẽ thực hiện việc schedule Pod. Khi tìm thấy node thích hợp, nó sẽ báo cho <strong>apiserver</strong> là Pod đó đã được bind vào node nào. <strong>apiserver</strong> sẽ lại update vào <strong>etcd</strong></li><li><strong>kubelet</strong> tại node đó sẽ thực hiện việc theo dõi container tạo bởi <strong>container runtime</strong> (Docker), xem chúng có chạy đúng với PodSpec không. <strong>kubelet</strong> sẽ gọi tới <strong>apiserver</strong> để update state của Pod đó thường xuyên.</li></ul><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="3-kiến-trúc-của-ứng-dụng-trên-kubernetes"></a>3. Kiến trúc của ứng dụng trên Kubernetes<a class="hash-link" href="#3-kiến-trúc-của-ứng-dụng-trên-kubernetes" title="Direct link to heading">#</a></h1><p>Ta sẽ chỉ tập trung vào 3 yếu tố chính để một hệ thống có thể hoạt động được:</p><ul><li>Ứng dụng</li><li>Network</li><li>Storage</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="31-pod"></a>3.1 Pod<a class="hash-link" href="#31-pod" title="Direct link to heading">#</a></h3><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="pod-là-gì"></a>Pod là gì<a class="hash-link" href="#pod-là-gì" title="Direct link to heading">#</a></h5><p><strong>Pod</strong> là đơn vị nhỏ nhất trong cluster. Mỗi Pod có IP riêng, và có thể chứa nhiều container, những container trong cùng 1 Pod có thể giao tiếp với nhau qua localhost. Vì vậy, có thể coi Pod là một máy ảo cho dễ hình dung.</p><p>Tuy nhiên để đơn giản, người ta thường chỉ chạy 1 container trên mỗi Pod, khi đó ta sẽ làm việc với Pod thay vì với từng container riêng lẻ.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="init-container"></a>Init container<a class="hash-link" href="#init-container" title="Direct link to heading">#</a></h5><p>Pod có hỗ trợ init container (1 hoặc nhiều đều được). Trước khi app container (container chính - ví dụ container với command <code>rails s</code>) chạy, tất cả init container sẽ được chạy lần lượt, cái trước thành công rồi đến cái sau chạy.</p><p>Ví dụ như 1 ứng dụng Rails, ta có thể settings <code>rails s</code> làm app container, còn <code>rails db:create db:migrate</code> sẽ làm init container.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="controller"></a>Controller<a class="hash-link" href="#controller" title="Direct link to heading">#</a></h5><p>Controller là 1 concept trong Kubernetes, nó dùng để theo dõi 1 loại Resource nào đó. <strong>kube-controller-manager</strong> có nhiệm vụ quản lý những controller này.</p><p>Về mặt kỹ thuật thì đây đơn thuần là 1 vòng lặp vô hạn (<em>control loop</em>) để có thể điều chỉnh state của cluster sao cho nó đạt tới được desired state.</p><p>Tuy nhiên đang trong mục Pod nên ta sẽ chỉ đề cập tới controller theo dõi Pod trong phần này.</p><ul><li><p><code>Deployment</code>:</p><p>Ta sẽ sử dụng <code>Deployment</code> khi cần deploy 1 hoặc nhiều replica (thường là stateless).</p><p>Thứ tự khởi động, identify của những replica (Pod) là hoàn toàn ngẫu nhiên.</p></li><li><p><code>StatefulSet</code>:</p><p>Nếu app của chúng ta là stateful (ví dụ như 1 set MySQL với 1 master và 2 slave), khi đó việc có 1 stable identity là rất quan trọng. Ngoài ra với mỗi replica trong <code>StatefulSet</code>, Kubernetes sẽ cung cấp cho nó một storage riêng.</p><p><code>StatefulSet</code> thêm prefix <code>0</code>, <code>1</code>, <code>2</code>, ... là thứ tự khởi động của pod vào tên pod.</p><p>Khi đó network identity, cũng như storage của Pod sẽ trở nên stable. Nếu mysql-0 của ta là master, nó sẽ luôn là master, và nó cũng luôn request tới storage của master.</p></li><li><p><code>DaemonSet</code>:</p><p>Ta dùng <code>DaemonSet</code> trong trường hợp muốn tất cả các node đều phải chạy 1 Pod nào đó.</p><p>Ví dụ như storage cluster như <strong>glusterd</strong>, hay log agent như <strong>fluentd</strong>, ...</p></li><li><p><code>Job</code>:</p><p>Khi ta cần chạy one-off Pod. Ví dụ như việc import master data.</p></li><li><p><code>CronJob</code>:</p><p>Như tên gọi của nó, cứ định kì nó sẽ tạo Pod để thực hiện job.</p></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="32-networking"></a>3.2 Networking<a class="hash-link" href="#32-networking" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="321-service"></a>3.2.1 Service<a class="hash-link" href="#321-service" title="Direct link to heading">#</a></h4><p>Trên môi trường production, rất hiếm khi ta thấy 1 service chỉ chạy trên 1 server. Thay vì thế, thường sẽ có 2 hoặc nhiều hơn server cùng chạy, khi server này chết, ta có thể forward request tới những server heo-thì (healthy) còn lại (trong trường hợp có set load balancer và healthcheck), không làm cho service của ta ngỏm luôn.</p><p>Tuy nhiên IP của Pod trong cluster luôn thay đổi, vậy thì ta biết phải setup cho load balancer như thế nào? Và đây chính là đất diễn của <code>Service</code>.</p><p><code>Service</code> là một tập hợp các Pod, thường sẽ dùng <code>label</code> để group các Pod.</p><p>Thông thường, mỗi <code>Service</code> sẽ được gán cho 1 cluster IP, Kubernetes sẽ cung cấp DNS name, và đồng thời cũng load-balance cho các Pod của <code>Service</code>.</p><p><img src="https://images.viblo.asia/2a7f4968-7280-47eb-a225-60ab2f06ab6e.png"></p><p>Ta cũng có thể sử dụng <code>Service</code> cho external endpoint.</p><p>Ví dụ khi hệ thống cần call đến <em><a href="https://google.com.vn" target="_blank" rel="noopener noreferrer">https://google.com.vn</a></em>. Tuy nhiên ta lại không muốn call trực tiếp, hay hardcode trong code, mà muốn endpoint này cũng trở thành 1 phần của cluster, để dễ quản lý. Khi đó ta có thể thay đổi endpoint này mà không phải đụng đến code, hay biến ENV gì đó. Khi đó, ta sẽ define 1 <code>Service</code>, và set <code>Endpoint</code> thủ công cho service này, thay vì sử dụng <code>label</code>.</p><p>Ngoài ra còn có <code>Headless Service</code>, loại service này sẽ không được gán cluster IP. Ta sẽ sử dụng khi ta muốn sử dụng cách load balance riêng, không phụ thuộc Kubernetes.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="322-load-balancer"></a>3.2.2 Load balancer<a class="hash-link" href="#322-load-balancer" title="Direct link to heading">#</a></h4><p>Khi tạo Service, nếu đây là service cho phép traffic từ bên ngoài Internet, ta hoàn toàn có thể sử dụng Load Balancer của các nhà cung cấp dịch vụ cloud (thường là L3 Load Balancer).</p><p>Khi call tới Load Balancer nói trên, nó sẽ trực tiếp forward traffic tới service trong cluster, thuật toán load-balance sẽ do Load Balancer này quyết định.</p><p><img src="https://images.viblo.asia/fdf97441-6cc1-4b42-ac48-342541d0421e.png"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="323-ingress"></a>3.2.3 Ingress<a class="hash-link" href="#323-ingress" title="Direct link to heading">#</a></h4><p><code>Ingress</code> hoạt động giống 1 Reverse Proxy hay Layer 7 Load Balancer. Nó cũng có nét tương đồng với API Gateway.</p><p><code>Ingress</code> có thể điều hướng cả internal traffic lẫn external traffic dựa vào URL, đồng thời cung cấp thêm cả load balancing giữa những pod của service. Một điểm đáng lưu ý là <code>Ingress</code> sẽ load balance trực tiếp các backend Pod mà không thông qua service, do đó, ta có thể tùy chỉnh được thuật toán, ... liên quan tới LB cho toàn bộ <code>Ingress</code> của cluster.</p><p>Ngoài ra, người ta cũng dùng <code>Ingress</code> để terminate TLS session.</p><p><img src="https://images.viblo.asia/5809feda-e282-4d5f-9cfb-11077d952add.jpg"></p><p>Kubernetes sau khi init mặc định sẽ không có ingress controller. Nếu ta chỉ tạo <code>Ingress</code> thì sẽ không có ý nghĩa gì. Để sử dụng <code>Ingress</code> ta sẽ phải setup thủ công Ingress Controller. Tuy nhiên việc này khá đơn giản, do nhiều hãng đã build sẵn mọi thứ, ta chỉ cần lấy file manifest của họ về rồi chạy là được.</p><ul><li>nginx: <a href="https://kubernetes.github.io/ingress-nginx/" target="_blank" rel="noopener noreferrer">NGINX Ingress Controller</a></li><li>traefik: <a href="https://docs.traefik.io/providers/kubernetes-ingress/" target="_blank" rel="noopener noreferrer">Kubernetes Ingress</a></li><li>...</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="324-practice"></a>3.2.4 Practice<a class="hash-link" href="#324-practice" title="Direct link to heading">#</a></h4><p><img src="https://images.viblo.asia/5001a20e-979c-473f-b2da-92c8668f621e.png"></p><ul><li>Traffic từ phía client sẽ được tập trung tại Layer 4 Load Balancer.</li><li>L4 LB sẽ phân bố traffic tới các Node trong cluster (thường qua <code>NodePort</code>).</li><li><code>Ingress</code> được map với <code>NodePort</code> đó sẽ terminate SSL, routing, và load balance traffic tới những Pod thích hợp.<ul><li>Traffic tới <code>/web</code> sẽ được điều hướng tới Frontend Pods</li><li>Traffic tới <code>/api</code> sẽ được điều hướng tới Backend Pods</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="33-storage---volume"></a>3.3 Storage - Volume<a class="hash-link" href="#33-storage---volume" title="Direct link to heading">#</a></h3><p>Một hệ thống khó có thể hoạt động chỉ với stateless service.</p><p>Với một số service như database, hay như tính năng upload file, ... Nếu chúng ta không sử dụng external service, thì service của ta sẽ trở thành stateful service. Nó đòi hỏi dữ liệu trong quá trình xử lý phải được lưu lại ngay cả khi bị crash. Ngoài ra có những lúc ta sẽ cần share dữ liệu giữa những container trong cùng 1 Pod. Những lúc như vậy, ta sẽ cần đến <strong>Volume</strong>.</p><p>Khi define Pod, ta sẽ chỉ rõ Pod này cần những volume nào, sau đó map những volume đó cho container.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="persistentvolume"></a>PersistentVolume<a class="hash-link" href="#persistentvolume" title="Direct link to heading">#</a></h5><p>Kubernetes sử dụng <code>PersistentVolume</code> để tạo nên 1 lớp abstract với những hệ thống storage thật phía sau. <code>PV</code> cũng có life-cycle giống như Pod.</p><p>Khi ta sử dụng volume, ta sẽ không cần quan tâm hệ thống đằng sau ngang dọc ra sao, thứ duy nhất ta cần quan tâm là API của <code>PersistentVolume</code>.</p><p>Trong Kubernetes, <code>PV</code> có thể được tạo bằng 2 cách:</p><ul><li>Dynamic Provisioning</li><li>Static Provisioning</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="static-provisioning"></a>Static Provisioning<a class="hash-link" href="#static-provisioning" title="Direct link to heading">#</a></h5><p>Admin cluster sẽ tạo ra 1 số <code>PV</code> trước, sau đó cung cấp cho bên Dev/Ops. Những <code>PV</code> này đã được trỏ tới hệ thống storage thật đang hoạt động đằng sau.</p><p>Có thể xem danh sách driver mà Kubernetes hỗ trợ tại <a href="https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes" target="_blank" rel="noopener noreferrer">đây</a>.</p><p>Ví dụ: Ta có 1 cluster Glusterfs với 3 node, tổng dung lượng là 3TB. Khi cần 10GB cho việc lưu trữ share resource, ta sẽ tạo <code>PersistentVolume</code> với dung lượng 10GB, trỏ tới cluster nói trên. Sau đó ta sẽ sử dụng volume trên tương tự như các volume khác trong hệ thống.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="dynamic-provisioning"></a>Dynamic Provisioning<a class="hash-link" href="#dynamic-provisioning" title="Direct link to heading">#</a></h5><p><code>PV</code> sẽ được tạo 1 cách động. Tức là khi nào Pod của ta cần volume, thì <code>PV</code> sẽ được tạo 1 cách tự động, nhờ vào <code>StorageClass</code> (sẽ đề cập sau).</p><p>Cách làm này đòi hỏi hệ thống storage của ta cũng phải support dynamic provisioning.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="persistentvolumeclaim"></a>PersistentVolumeClaim<a class="hash-link" href="#persistentvolumeclaim" title="Direct link to heading">#</a></h5><p>Để có thể sử dụng được <code>PV</code>, ta cần tạo thêm <code>PersistentVolumeClaim</code> (PVC).</p><p>Ta có thể sử dụng Claim trên cho config, hay volume, ... của Pod.</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="4-high-availability-setup"></a>4. High Availability Setup<a class="hash-link" href="#4-high-availability-setup" title="Direct link to heading">#</a></h1><p><img src="https://images.viblo.asia/48635fac-b09b-4174-b279-4f8d0fa29fb6.png"></p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="5-reference"></a>5. Reference<a class="hash-link" href="#5-reference" title="Direct link to heading">#</a></h1><p>kubernetes.io - <a href="https://documentationo/docs/home/" target="_blank" rel="noopener noreferrer">Kubernetes Official Documentation</a></p><p>youtube.com - <a href="https://www.youtube.com/watch?v=GXq3FS8M_kw" target="_blank" rel="noopener noreferrer">June 2018 Online Meetup: Kubernetes Networking Master Class</a></p><p>x-team.com - <a href="https://x-team.com/blog/introduction-kubernetes-architecture/" target="_blank" rel="noopener noreferrer">INTRODUCTION TO KUBERNETES ARCHITECTURE</a></p><p>ovh.com - <a href="https://www.ovh.com/blog/getting-external-traffic-into-kubernetes-clusterip-nodeport-loadbalancer-and-ingress/" target="_blank" rel="noopener noreferrer">Getting external traffic into Kubernetes – ClusterIp, NodePort, LoadBalancer, and Ingress</a></p><p>medium.com - <a href="https://medium.com/jorgeacetozi/kubernetes-master-components-etcd-api-server-controller-manager-and-scheduler-3a0179fc8186" target="_blank" rel="noopener noreferrer">Kubernetes Master Components: Etcd, API Server, Controller Manager, and Scheduler</a></p><p>medium.com - <a href="https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0" target="_blank" rel="noopener noreferrer">Kubernetes NodePort vs LoadBalancer vs Ingress? When should I use what?</a></p></div><footer class="row margin-vert--lg"><div class="col"><strong>Tags:</strong><a class="margin-horiz--sm" href="/blog/tags/devops">devops</a><a class="margin-horiz--sm" href="/blog/tags/kubernetes">kubernetes</a><a class="margin-horiz--sm" href="/blog/tags/introduction">introduction</a></div><div class="col text--right"><a aria-label="Read more about Giới thiệu về Kubernetes" href="/blog/gioi-thieu-ve-kubernetes"><strong>Read More</strong></a></div></footer></article></div></main></div></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Self notes</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/moonlight8978/moonlight8978.github.io" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li><li class="footer__item"><a href="https://stackoverflow.com/users/8068639/moonlight8978" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 moonlight8978. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.610c7904.js"></script>
<script src="/assets/js/main.afbd8574.js"></script>
</body>
</html>